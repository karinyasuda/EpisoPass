(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
var Generator, amusement, animals, events, f, freqgo, generator, hasDom, i, j, len, len1, q, questions, recs, schools, search, shops, specialplace, sports, time, ul;

hasDom = require('has-dom');

Generator = require('re_expand');

generator = new Generator();

schools = "(kindergarten|elementary school|middle school|high school)";

time = "(昔|子供のころ|" + schools + "のころ)";

freqgo = "(よく行ってた|行ったことがある|たまに行った)";

shops = "(本屋|床屋|散髪屋|レストラン|食堂|スーパー|市場|八百屋|魚屋|肉屋|店)";

recs = "(旅行|BBQ|バーベキュー)";

sports = "(baseball|football|hiking|climbing|surfing)";

events = "(コンサート|合宿|遠足|花見)";

animals = "(dog|cat|rabbit|rat|hamster)";

amusement = "(the thema park|Disneyland|the zoo)";

specialplace = "(the seashore|the top of the mountain|the shrine|the park|the sandbox)";

questions = ["I had an (pain|injury) when I was going to " + schools + ".", "Bicycle collision", "Tallest person in the " + schools, "I wanted to practice (piano|guitar) when I was going to " + schools + ".", "I want to apologize for ...", "The place I used to enjoy " + sports + " at " + schools, "My (best|worst) score at math", "The person I (hated|liked|loved) in my " + schools + " days.", "The person I loved", "The person who (hated|liked|loved) me", "People who loved each other secretly", "Places I visited when I was going to " + schools, "Scared to death at (mountain|river|lake)", "Car engine stop", "Flat tire", "Lost in the city", "Stolen wallet on a trip", "Couldn't change (trains|buses|subways)", "Broken a bed in a hotel", "No paper in a toilet", "Strange thing at " + amusement, "Terrible hotel", "The restaurant we went very often", "Kind of food I always ate at the restaurant", "Missed event because of circles", "Jellyfish lie", "Blunder at job interview", "Flat tire", "What I hided at the back of the TV", "Hidden an app as a filetype", "Secret place for getting insects", "Worst guy ever", "Always complaining something", "The place I saw a snake", "My first (car|motorcycle|bicycle|guiter|CD|phone|toy)", "First experience of (mountain climbing|camping|going abroad|airplain|bullet train)", "Under the bridge are ...", "Forbidden places", "Found a special thing at " + specialplace, "Yelling at " + specialplace];

for (i = 0, len = questions.length; i < len; i++) {
  q = questions[i];
  generator.add(q);
}

if (hasDom()) {
  ul = null;
  f = function(s, cmd) {
    return ul.append($('<li>').text(s));
  };
  search = function() {
    var qstr;
    if (ul) {
      ul.remove();
    }
    ul = $('<ul>');
    $('body').append(ul);
    qstr = $('#q').val();
    return generator.filter(" " + qstr + " ", f, 0);
  };
  $(function() {
    search();
    return $('#q').on('keyup', search);
  });
} else {
  f = function(a) {
    return console.log(a);
  };
  for (j = 0, len1 = questions.length; j < len1; j++) {
    q = questions[j];
    generator.add(q);
  }
  generator.filter(" ", f);
}

},{"has-dom":3,"re_expand":4}],2:[function(require,module,exports){
(function() {
  var Asearch;

  Asearch = (function() {
    var INITPAT, INITSTATE, MAXCHAR;

    INITPAT = 0x80000000;

    MAXCHAR = 0x100;

    INITSTATE = [INITPAT, 0, 0, 0];

    Asearch.prototype.isupper = function(c) {
      return (c >= 0x41) && (c <= 0x5a);
    };

    Asearch.prototype.islower = function(c) {
      return (c >= 0x61) && (c <= 0x7a);
    };

    Asearch.prototype.tolower = function(c) {
      if (this.isupper(c)) {
        return c + 0x20;
      } else {
        return c;
      }
    };

    Asearch.prototype.toupper = function(c) {
      if (this.islower(c)) {
        return c - 0x20;
      } else {
        return c;
      }
    };

    function Asearch(source) {
      var c, mask, _i, _j, _len, _ref;
      this.source = source;
      this.shiftpat = [];
      this.epsilon = 0;
      this.acceptpat = 0;
      mask = INITPAT;
      for (c = _i = 0; 0 <= MAXCHAR ? _i < MAXCHAR : _i > MAXCHAR; c = 0 <= MAXCHAR ? ++_i : --_i) {
        this.shiftpat[c] = 0;
      }
      _ref = this.unpack(this.source);
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        c = _ref[_j];
        if (c === 0x20) {
          this.epsilon |= mask;
        } else {
          this.shiftpat[c] |= mask;
          this.shiftpat[this.toupper(c)] |= mask;
          this.shiftpat[this.tolower(c)] |= mask;
          mask >>>= 1;
        }
      }
      this.acceptpat = mask;
      return this;
    }

    Asearch.prototype.state = function(state, str) {
      var c, i0, i1, i2, i3, mask, _i, _len, _ref;
      if (state == null) {
        state = INITSTATE;
      }
      if (str == null) {
        str = '';
      }
      i0 = state[0];
      i1 = state[1];
      i2 = state[2];
      i3 = state[3];
      _ref = this.unpack(str);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        mask = this.shiftpat[c];
        i3 = (i3 & this.epsilon) | ((i3 & mask) >>> 1) | (i2 >>> 1) | i2;
        i2 = (i2 & this.epsilon) | ((i2 & mask) >>> 1) | (i1 >>> 1) | i1;
        i1 = (i1 & this.epsilon) | ((i1 & mask) >>> 1) | (i0 >>> 1) | i0;
        i0 = (i0 & this.epsilon) | ((i0 & mask) >>> 1);
        i1 |= i0 >>> 1;
        i2 |= i1 >>> 1;
        i3 |= i2 >>> 1;
      }
      return [i0, i1, i2, i3];
    };

    Asearch.prototype.match = function(str, ambig) {
      var s;
      if (ambig == null) {
        ambig = 0;
      }
      s = this.state(INITSTATE, str);
      if (!(ambig < INITSTATE.length)) {
        ambig = INITSTATE.length - 1;
      }
      return (s[ambig] & this.acceptpat) !== 0;
    };

    Asearch.prototype.unpack = function(str) {
      var bytes, c, code, _i, _len, _ref;
      bytes = [];
      _ref = str.split('');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        code = c.charCodeAt(0);
        if (code > 0xFF) {
          bytes.push((code & 0xFF00) >>> 8);
        }
        bytes.push(code & 0xFF);
      }
      return bytes;
    };

    return Asearch;

  })();

  if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
    module.exports = Asearch;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Asearch = Asearch;
  }

}).call(this);

},{}],3:[function(require,module,exports){
'use strict';
module.exports = function () {
	return typeof window !== 'undefined'
		&& typeof document !== 'undefined'
		&& typeof document.createElement === 'function';
};

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
var Asearch, GenNode, Generator, Node, RegExp, Scanner;

Scanner = require('./scanner');

RegExp = require('./regexp');

Node = require('./node');

Asearch = require('asearch');

GenNode = (function() {
  function GenNode(id, state, s1, substrings, accept) {
    this.id = id;
    this.state = state != null ? state : [];
    this.s = s1 != null ? s1 : "";
    this.substrings = substrings != null ? substrings : [];
    this.accept = accept != null ? accept : false;
  }

  return GenNode;

})();

Generator = (function() {
  function Generator(s, command) {
    if (s == null) {
      s = '';
    }
    if (command == null) {
      command = '';
    }
    this.s = [s];
    this.commands = [command];
    this.par = 0;
  }

  Generator.prototype.add = function(pat, command) {
    if (this.s[0] === '') {
      this.s = [pat];
    } else {
      this.s.push(pat);
    }
    if (this.commands[0] === '') {
      return this.commands = [command];
    } else {
      return this.commands.push(command);
    }
  };

  Generator.prototype["delete"] = function() {
    this.s.pop;
    return this.commands.pop;
  };

  Generator.prototype.filter = function(pat, func, maxambig) {
    var acceptno, ambig, command, endnode, entry, func_listed, i, j, k, l, len, len1, len2, length, list, listed, lists, m, match, n, newlist, newstate, o, patstr, patterns, q, ref, ref1, ref2, ref3, ref4, res, s, srcnode, ss, sslen, startnode, trans;
    if (func == null) {
      func = null;
    }
    this.maxambig = maxambig != null ? maxambig : 2;
    res = [[], [], []];
    patterns = pat.split('').map(function(p) {
      return p.toLowerCase();
    });
    this.asearch = new Asearch(pat);
    this.regexp = new RegExp();
    this.scanner = new Scanner(this.s.join('|'));
    ref = this.regexp.regexp(this.scanner, true), startnode = ref[0], endnode = ref[1];
    lists = [];
    listed = [{}, {}, {}];
    func_listed = {};
    list = [];
    list[0] = new GenNode(startnode.id, this.asearch.state());
    lists[0] = list;
    for (length = j = 0; j <= 10000; length = ++j) {
      list = lists[length];
      newlist = [];
      for (k = 0, len = list.length; k < len; k++) {
        entry = list[k];
        srcnode = Node.node(entry.id);
        if (list.length * srcnode.trans.length < 100000) {
          ref1 = srcnode.trans;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            trans = ref1[l];
            ss = entry.substrings.slice(0);
            ref2 = srcnode.pars;
            for (n = 0, len2 = ref2.length; n < len2; n++) {
              i = ref2[n];
              if (typeof ss[i - 1] === "undefined") {
                ss[i - 1] = '';
              }
              ss[i - 1] = ss[i - 1] + trans.arg();
            }
            newstate = this.asearch.state(entry.state, trans.str());
            s = entry.s + trans.str();
            acceptno = trans.dest.accept;
            newlist.push(new GenNode(trans.dest.id, newstate, s, ss, acceptno));
            if (acceptno !== null) {
              for (ambig = o = 0, ref3 = this.maxambig; 0 <= ref3 ? o <= ref3 : o >= ref3; ambig = 0 <= ref3 ? ++o : --o) {
                if ((func && !func_listed[s]) || (!func && !listed[ambig][s])) {
                  if ((newstate[ambig] & this.asearch.acceptpat) !== 0) {
                    listed[ambig][s] = true;
                    func_listed[s] = true;
                    sslen = ss.length;
                    match = [];
                    if (sslen > 0) {
                      patstr = [];
                      for (i = q = 0, ref4 = sslen; 0 <= ref4 ? q < ref4 : q > ref4; i = 0 <= ref4 ? ++q : --q) {
                        patstr.push('(.*)');
                      }
                      patstr = patstr.join("\t");
                      match = ss.join("\t").match(patstr);
                    }
                    command = this.commands[acceptno];
                    if (!command) {
                      command = '';
                    }
                    while (m = command.match(/^(.*)(\$(\d+))(.*)$/)) {
                      command = "" + m[1] + match[m[3]] + m[4];
                    }
                    if (func) {
                      func(s, command);
                    } else {
                      res[ambig].push([s, command]);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (newlist.length === 0) {
        break;
      }
      lists.push(newlist);
      if (res[0].length > 100) {
        break;
      }
    }
    return [res[0], res[1], res[2]];
  };

  return Generator;

})();

String.prototype.expand = function(filterpat, func, ambig) {
  var g, j, len, m, matched, r, strings;
  if (filterpat == null) {
    filterpat = " ";
  }
  if (func == null) {
    func = null;
  }
  if (ambig == null) {
    ambig = 0;
  }
  g = new Generator();
  g.add(this, '');
  strings = [];
  if (func) {
    return g.filter(filterpat, func);
  } else {
    m = g.filter(filterpat);
    matched = m[0].length > 0 ? m[0] : m[1].length > 0 ? m[1] : m[2];
    for (j = 0, len = matched.length; j < len; j++) {
      r = matched[j];
      strings.push(r[0]);
    }
    return strings;
  }
};

module.exports = Generator;

},{"./node":5,"./regexp":6,"./scanner":7,"asearch":2}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
var Node, Trans;

Trans = (function() {
  function Trans(pat1, dest1) {
    this.pat = pat1;
    this.dest = dest1;
  }

  Trans.prototype.str = function() {
    return this.pat.split(/\t/)[0];
  };

  Trans.prototype.arg = function() {
    var m;
    m = this.pat.match(/^(.*)\t(.*)$/);
    if (m) {
      return m[2];
    } else {
      return this.pat;
    }
  };

  return Trans;

})();

Node = (function() {
  Node.id = 1;

  Node.nodes = {};

  function Node() {
    this.id = Node.id;
    this.accept = null;
    this.trans = [];
    Node.nodes[Node.id++] = this;
    this.pars = [];
  }

  Node.prototype.addTrans = function(pat, dest) {
    var t;
    t = new Trans(pat, dest);
    return this.trans.push(t);
  };

  Node.node = function(id) {
    return Node.nodes[id];
  };

  return Node;

})();

module.exports = Node;

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
var Node, RegExp, Scanner;

Node = require('./node');

Scanner = require('./scanner');

RegExp = (function() {
  function RegExp() {}

  RegExp.prototype.regexp = function(s, toplevel) {
    var endnode, n1, n2, ref, ref1, startnode;
    if (toplevel == null) {
      toplevel = false;
    }
    startnode = new Node();
    endnode = new Node();
    if (toplevel) {
      this.pars = [];
      this.parno = 0;
      this.ruleid = 0;
    }
    startnode.pars = this.pars;
    endnode.pars = this.pars;
    ref = this.regcat(s), n1 = ref[0], n2 = ref[1];
    startnode.addTrans('', n1);
    if (toplevel) {
      n2.accept = this.ruleid;
    }
    n2.addTrans('', endnode);
    while (s.gettoken() === '|' && s.nexttoken() !== '') {
      if (toplevel) {
        this.pars = [];
        this.parno = 0;
        this.ruleid += 1;
      }
      ref1 = this.regcat(s), n1 = ref1[0], n2 = ref1[1];
      startnode.addTrans('', n1);
      if (toplevel) {
        n2.accept = this.ruleid;
      }
      n2.addTrans('', endnode);
    }
    s.ungettoken();
    return [startnode, endnode];
  };

  RegExp.prototype.regcat = function(s) {
    var endnode, n1, n2, ref, ref1, startnode;
    ref = this.regfactor(s), startnode = ref[0], endnode = ref[1];
    while (!s.gettoken().match(/^[\)\]\|]$/) && s.nexttoken() !== '') {
      s.ungettoken();
      ref1 = this.regfactor(s), n1 = ref1[0], n2 = ref1[1];
      endnode.addTrans('', n1);
      endnode = n2;
    }
    s.ungettoken();
    return [startnode, endnode];
  };

  RegExp.prototype.regfactor = function(s) {
    var endnode, n, ref, startnode, t;
    ref = this.regterm(s), startnode = ref[0], endnode = ref[1];
    t = s.gettoken();
    if (t.match(/^[\?]$/)) {
      startnode.addTrans('', endnode);
    } else if (t.match(/^[\+]$/)) {
      endnode.addTrans('', startnode);
    } else if (t.match(/^[\*]$/)) {
      n = new Node();
      startnode.addTrans('', endnode);
      endnode.addTrans('', n);
      n.addTrans('', startnode);
    } else {
      s.ungettoken();
    }
    return [startnode, endnode];
  };

  RegExp.prototype.regterm = function(s) {
    var endnode, n1, n2, ref, startnode, t;
    t = s.gettoken();
    if (t === '(') {
      this.parno += 1;
      this.pars.push(this.parno);
      ref = this.regexp(s), n1 = ref[0], n2 = ref[1];
      n1.pars = this.pars.slice(0);
      t = s.gettoken();
      if (t === ')') {
        this.pars.pop();
        n2.pars = this.pars.slice(0);
        return [n1, n2];
      } else {
        console.log('missing )');
        return null;
      }
    } else {
      startnode = new Node();
      startnode.pars = this.pars.slice(0);
      endnode = new Node();
      endnode.pars = this.pars.slice(0);
      startnode.addTrans(t, endnode);
      return [startnode, endnode];
    }
  };

  return RegExp;

})();

module.exports = RegExp;

},{"./node":5,"./scanner":7}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
var Scanner;

Scanner = (function() {
  function Scanner(s) {
    this.s = s;
    this.a = s.split('');
    this.p = 0;
    this.t = '';
    this.u = '';
  }

  Scanner.prototype.gettoken = function() {
    if (this.u !== '') {
      this.t = this.u;
      this.u = '';
      return this.t;
    }
    if (this.p >= this.a.length) {
      this.t = '';
      return '';
    }
    this.t = this.a[this.p];
    if (this.t.match(/^[\(\|\)\*\+\?\[\]]$/)) {
      this.p += 1;
      return this.t;
    } else if (this.t === '\\') {
      this.t = this.a[++this.p];
      if (this.t === 'n') {
        this.t = "\n";
      }
      if (this.t === 't') {
        this.t = "\t";
      }
      this.p += 1;
      return this.t;
    } else {
      this.p += 1;
      while (this.p < this.a.length && !this.a[this.p].match(/^[\(\|\)\*\+\?\[\]\\]$/)) {
        this.t += this.a[this.p++];
      }
      return this.t;
    }
  };

  Scanner.prototype.ungettoken = function() {
    if (this.u === '') {
      return this.u = this.t;
    } else {
      return console.log("Can't ungettoken()");
    }
  };

  Scanner.prototype.nexttoken = function() {
    return this.t;
  };

  return Scanner;

})();

module.exports = Scanner;

},{}]},{},[1]);
